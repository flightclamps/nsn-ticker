<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1080, height=1920, initial-scale=1.0">
    <title>NOTSOCJ TikTok Dual Stream</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&family=Oswald:wght@500;700&display=swap" rel="stylesheet">

    <style>
        /* --- 1. THEME: CYBER DATA --- */
        :root {
            --neon-cyan: #00f2ea;
            --neon-pink: #ff0050;
            --neon-orange: #ff9900;
            --neon-purple: #bc13fe; 
            --glass-panel: rgba(10, 10, 15, 0.95);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        
        body {
            background-color: transparent; 
            background-image: 
                linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.9)),
                repeating-linear-gradient(45deg, #111 0px, #111 2px, #000 2px, #000 8px);
            font-family: 'Oswald', sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
            color: white;
        }

        /* --- 2. TOP ANCHOR HUB --- */
        .broadcast-hub {
            position: absolute; top: 140px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 900px;
            display: flex; flex-direction: column;
            gap: 12px;
            z-index: 100;
        }

        /* --- 3. THE DOUBLE SCROLLER --- */
        .double-ticker {
            display: flex; flex-direction: column;
            border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            position: relative;
        }

        /* NEXT GEN SCANNER EFFECT */
        .double-ticker::after {
            content: '';
            position: absolute; top: 0; left: -50%; width: 20%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: skewX(-20deg);
            animation: scanBeam 4s infinite ease-in-out;
            pointer-events: none;
            z-index: 50;
        }
        @keyframes scanBeam { 
            0% { left: -50%; opacity: 0; } 
            50% { opacity: 1; }
            100% { left: 150%; opacity: 0; } 
        }

        /* SHARED TRACK STYLES */
        .ticker-row {
            position: relative; overflow: hidden; display: flex; align-items: center;
            width: 100%;
        }
        
        .track-container {
            display: flex;
            align-items: center;
            white-space: nowrap;
            /* GPU ACCELERATION ON */
            will-change: transform;
        }

        /* CSS KEYFRAMES FOR SMOOTH SCROLLING */
        @keyframes scrollMarquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        /* LINE 1: SCORES */
        .ticker-row.line-1 {
            height: 60px; background: rgba(0, 40, 80, 0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .score-chip {
            display: flex; align-items: center; gap: 10px;
            padding: 0 25px; color: #fff; font-size: 24px; font-weight: 700;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .tiny-logo { width: 30px; height: 30px; object-fit: contain; }
        .live-indicator { color: var(--neon-cyan); font-size: 14px; margin-left: 5px; animation: pulse 1s infinite; }
        .sport-icon { font-size: 16px; opacity: 0.7; margin-right: 5px; }
        
        @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.5;} }

        /* LINE 2: STATS & AI */
        .ticker-row.line-2 {
            height: 50px; background: rgba(5, 5, 10, 0.98);
        }
        .stat-chip {
            display: flex; align-items: center; gap: 8px;
            padding: 0 20px; color: #ccc; font-size: 18px; font-weight: 500;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .stat-val { color: var(--neon-pink); font-weight: 700; }
        .stat-val.nba { color: var(--neon-orange); }
        
        .ai-chip {
            font-family: 'JetBrains Mono', monospace;
            color: var(--neon-purple);
            text-shadow: 0 0 5px var(--neon-purple);
            font-size: 16px;
            font-weight: 800;
        }

        .engage-chip { 
            color: var(--neon-cyan); font-weight: 700; text-transform: uppercase; 
            animation: glowText 2s infinite; 
        }
        
        @keyframes glowText { 0%,100%{text-shadow: 0 0 5px var(--neon-cyan);} 50%{text-shadow: none;} }

    </style>
</head>
<body>

    <!-- BROADCAST HUB -->
    <div class="broadcast-hub">

        <!-- DOUBLE SCROLLER -->
        <div class="double-ticker">
            <!-- LINE 1: SCORES -->
            <div class="ticker-row line-1">
                <div class="track-container" id="track1"></div>
            </div>
            <!-- LINE 2: STATS / AI / ENGAGEMENT -->
            <div class="ticker-row line-2">
                <div class="track-container" id="track2"></div>
            </div>
        </div>

    </div>

    <script>
        class DualStreamOverlay {
            constructor() {
                this.nflApi = 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard';
                this.nbaApi = 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard';
                
                this.t1 = document.getElementById('track1');
                this.t2 = document.getElementById('track2');
                
                this.init();
            }

            async init() {
                await this.fetchData();
                setInterval(() => this.fetchData(), 20000); 
            }

            async fetchData() {
                try {
                    const [nflRes, nbaRes] = await Promise.all([
                        fetch(this.nflApi),
                        fetch(this.nbaApi)
                    ]);
                    
                    const nflData = await nflRes.json();
                    const nbaData = await nbaRes.json();
                    
                    this.games = [];
                    this.stats = [];

                    if(nflData.events) this.processEvents(nflData.events, 'nfl');
                    if(nbaData.events) this.processEvents(nbaData.events, 'nba');
                    
                    // Add Engagement
                    const eng = ["TAP THE SCREEN", "FOLLOW NOTSOCJ", "W CHAT", "NOTSOCJ LIVE"];
                    eng.forEach(e => this.stats.push({txt: e, type: 'engage'}));

                    // Rebuild content periodically or if empty
                    this.updateDOM();

                } catch(e) { console.error(e); }
            }

            processEvents(events, sport) {
                events.forEach(e => {
                    const c = e.competitions[0];
                    const h = c.competitors.find(x => x.homeAway === 'home');
                    const a = c.competitors.find(x => x.homeAway === 'away');
                    const isLive = e.status.type.state === 'in';
                    const isPre = e.status.type.state === 'pre';

                    // 1. Add Game
                    this.games.push({
                        sport: sport,
                        hT: h.team.abbreviation, hS: h.score, hL: h.team.logo,
                        aT: a.team.abbreviation, aS: a.score, aL: a.team.logo,
                        status: e.status,
                        isLive: isLive
                    });

                    // 2. CORTEX v2.0 Logic
                    if(isLive || isPre) {
                        let aiMsg = "";
                        
                        if (isPre) {
                            const homeFav = Math.random() > 0.5;
                            const favTeam = homeFav ? h.team.abbreviation : a.team.abbreviation;
                            const prob = Math.floor(Math.random() * 25) + 50; 
                            aiMsg = `CORTEX v2.0 [${sport.toUpperCase()}]: PRE-GAME SIM - ${favTeam} ${prob}% FAVORITE`;
                        } 
                        else {
                            const hScore = parseInt(h.score);
                            const aScore = parseInt(a.score);
                            const diff = Math.abs(hScore - aScore);
                            const leader = hScore > aScore ? h.team.abbreviation : a.team.abbreviation;
                            let prob = 50;
    
                            if (sport === 'nfl') {
                                if (diff === 0) aiMsg = `CORTEX v2.0 [NFL]: TIED GAME - HIGH TENSION`;
                                else if (diff <= 8) aiMsg = `CORTEX v2.0 [NFL]: ONE POSSESSION GAME - ${leader} LEADING`;
                                else {
                                    prob = Math.min(99, 55 + diff);
                                    aiMsg = `CORTEX v2.0 [NFL]: ${leader} CONTROL (${prob}% WIN PROB)`;
                                }
                            } else if (sport === 'nba') {
                                if (diff <= 3) aiMsg = `CORTEX v2.0 [NBA]: CLUTCH TIME - DEAD HEAT`;
                                else if (diff <= 10) aiMsg = `CORTEX v2.0 [NBA]: CLOSE CONTEST - ${leader} EDGE`;
                                else {
                                    prob = Math.min(99, 50 + (diff/2));
                                    aiMsg = `CORTEX v2.0 [NBA]: ${leader} DOMINATING (${Math.floor(prob)}%)`;
                                }
                            }
                        }
                        
                        this.stats.push({ txt: aiMsg, type: 'ai' });
                    }

                    // 3. Add Top Performers
                    if(c.leaders) {
                        c.leaders.forEach(cat => {
                            if(cat.leaders && cat.leaders[0]) {
                                const p = cat.leaders[0];
                                const statName = cat.abbreviation || cat.name;
                                this.stats.push({
                                    txt: `${p.athlete.shortName}: ${p.displayValue} ${statName}`,
                                    type: 'stat',
                                    sport: sport
                                });
                            }
                        });
                    }
                });
            }

            updateDOM() {
                // GENERATE LINE 1 (SCORES)
                let html1 = '';
                if(this.games.length === 0) {
                     html1 = `<div class="score-chip">WAITING FOR LIVE DATA...</div>`;
                } else {
                    this.games.forEach(g => {
                        const liveDot = g.isLive ? '<span class="live-indicator">‚óè LIVE</span>' : '';
                        const clock = g.isLive ? (g.status.displayClock || '') : g.status.type.shortDetail;
                        const icon = g.sport === 'nfl' ? 'üèà' : 'üèÄ';
                        html1 += `
                            <div class="score-chip">
                                <span class="sport-icon">${icon}</span>
                                <img src="${g.aL}" class="tiny-logo"> ${g.aT} ${g.aS}
                                <span style="margin:0 8px; color:#555; font-size:16px;">@</span>
                                ${g.hS} ${g.hT} <img src="${g.hL}" class="tiny-logo">
                                <span style="font-size:14px; color:#aaa; margin-left:10px;">${clock}</span>
                                ${liveDot}
                            </div>`;
                    });
                }
                
                // GENERATE LINE 2 (STATS)
                let html2 = '';
                this.stats.sort(()=>Math.random()-0.5).forEach(s => {
                    if(s.type === 'stat') {
                        const colorClass = s.sport === 'nba' ? 'nba' : '';
                        html2 += `<div class="stat-chip">‚ö° ${s.txt.split(':')[0]}: <span class="stat-val ${colorClass}">${s.txt.split(':')[1]}</span></div>`;
                    } else if (s.type === 'ai') {
                        html2 += `<div class="stat-chip ai-chip">ü§ñ ${s.txt}</div>`;
                    } else {
                        html2 += `<div class="stat-chip engage-chip">üí¨ ${s.txt}</div>`;
                    }
                });
                if(!html2) html2 = '<div class="stat-chip engage-chip">NOTSOCJ LIVE BROADCAST</div>';

                // APPLY TO DOM
                // We use 2 copies to create the seamless infinite loop
                this.t1.innerHTML = html1 + html1;
                this.t2.innerHTML = html2 + html2;

                // RESTART ANIMATIONS
                this.startCSSAnimation(this.t1, 60); // 60px/sec speed reference
                this.startCSSAnimation(this.t2, 50); // 50px/sec (slower)
            }

            startCSSAnimation(element, speedFactor) {
                // Remove animation to reset
                element.style.animation = 'none';
                element.offsetHeight; /* trigger reflow */
                
                // Calculate width to determine duration
                // We only need the width of ONE set of content (half the total width)
                const totalWidth = element.scrollWidth;
                const singleSetWidth = totalWidth / 2;
                
                // Duration = Distance / Speed
                const duration = singleSetWidth / speedFactor; 
                
                element.style.animation = `scrollMarquee ${duration}s linear infinite`;
            }
        }

        const app = new DualStreamOverlay();
    </script>
</body>
</html>
