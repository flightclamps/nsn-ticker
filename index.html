<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NSN SPORTS â€¢ Ultimate Stream Ticker</title>

<style>
    /* Custom CSS - Using Inter font and modern styling */
    body {
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: 'Inter', sans-serif;
    }

    /* Ticker Bar Styling */
    .nsn-bar {
        width: 100vw;
        height: 72px; /* Slightly taller for impact */
        background: #0a0a0a;
        border-top: 4px solid #FFD700; /* Gold/Yellow accent */
        border-bottom: 4px solid #1E88E5; /* Blue accent */
        display: flex;
        align-items: center;
        position: fixed;
        bottom: 0;
        left: 0;
        box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
    }

    /* Logo Section - Aggressive Gradient */
    .nsn-logo {
        width: 300px; /* Wider logo space */
        height: 100%;
        background: linear-gradient(135deg, #1E88E5, #0056b3);
        border-right: 4px solid #FFD700;
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding-left: 15px;
        box-sizing: border-box;
        flex-shrink: 0; 
        border-radius: 0 10px 10px 0;
        position: relative;
        overflow: hidden;
    }
    .nsn-logo::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 20px;
        background: linear-gradient(to right, rgba(10, 10, 10, 0) 0%, #0a0a0a 100%);
        pointer-events: none;
    }
    
    .nsn-title {
        font-size: 26px;
        font-weight: 900;
        color: #fff;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        letter-spacing: 1px;
    }
    .nsn-sub {
        font-size: 12px;
        color: #d6ecff;
        font-weight: 500;
    }
    .nsn-sponsor {
        font-size: 11px;
        color: #FFD700;
        opacity: 0.95;
        margin-top: 5px;
        font-weight: 700;
    }

    /* Scrolling Area */
    .scroll-area {
        flex: 1;
        overflow: hidden;
        position: relative;
        height: 100%;
        margin-left: 20px;
    }

    /* The track holds the content (and its duplicate) */
    .scroll-track {
        white-space: nowrap;
        font-size: 24px;
        font-weight: 700;
        color: #fff;
        height: 100%;
        display: inline-block;
        min-width: 200%; 
        display: flex;
        align-items: center;
        transition: none !important; /* Prevent CSS transitions from interfering */
    }

    /* CSS Keyframe Animation: Scrolls the content from 0% to -50% (the width of the original content) */
    /* Duration is now set dynamically in JavaScript */
    @keyframes tickerScroll {
        from { transform: translateX(0%); }
        to { transform: translateX(-50%); } 
    }
    
    .item {
        margin-right: 80px; /* Wider spacing */
        flex-shrink: 0;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
    }

    /* Label Styling */
    .label {
        font-weight: 900;
        margin-right: 12px;
        padding: 5px 10px;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        font-size: 18px;
        text-shadow: none;
        letter-spacing: 0.5px;
        /* Default for LIVE and NEWS */
        background-color: #333;
        color: #FFD700; 
    }
    
    .label.SCORE {
        background: #1E88E5;
        color: #fff;
    }
    .label.LIVE {
        background: #D32F2F; /* Red for LIVE */
        color: #fff;
    }
    .label.CHAT {
        background: #7B1FA2; /* Purple for Stream Engagement */
        color: #fff;
    }
    .label.RUMOR {
        background: #FF9800; /* Orange for Rumors */
        color: #000;
    }
    .label.TEAM {
        background: #4CAF50; /* Green for Team Prompts */
        color: #fff;
    }
    .label.SYSTEM {
        background: #607D8B; /* Grey for System Messages */
        color: #fff;
    }


    /* Status Text Styling for in-game status */
    .status-text {
        font-size: 18px;
        font-weight: 500;
        color: #FFD700;
        margin-left: 12px;
        padding-left: 12px;
        border-left: 2px solid #555;
    }

    /* Score Separator */
    .score-sep {
        color: #FFD700;
        margin: 0 10px;
    }

    /* Loading/Error State Message */
    #loading-message {
        color: #fff;
        font-size: 20px;
        font-weight: 500;
        margin-left: 20px;
    }

</style>
</head>

<body>

<div class="nsn-bar">
    <div class="nsn-logo">
        <div class="nsn-title">NSN LIVE</div>
        <div class="nsn-sub">REAL-TIME SCORES, RUMORS, & CHAT</div>
        <div class="nsn-sponsor">PRESENTED BY: HYPE FUEL ENERGY</div>
    </div>

    <div class="scroll-area">
        <div class="scroll-track" id="track">
             <!-- Loading message shown until JS fully runs -->
            <div id="loading-message">
                LOADING REAL-TIME SPORTS DATA...
            </div>
        </div>
    </div>
</div>

<script>
    // ==============================
    // SETTINGS / CONFIGURATION
    // ==============================
    const PIXELS_PER_SEC = 80;       // FAST: Constant scroll speed in pixels per second
    const REFRESH_MS_MIN = 30000;    // Minimum 30s refresh interval for live data
    // Use the CORS Proxy endpoint
    const proxyBase = "https://corsproxy.io/?"; 
    
    const track = document.getElementById("track");
    let refreshTimeout; // Holds the timeout ID for the next content refresh

    // --- Ticker Data Sources ---
    const scoreboardSources = [
        { label: "NBA", url: proxyBase + encodeURIComponent("https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard") },
        { label: "NFL", url: proxyBase + encodeURIComponent("https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard") },
        { label: "NHL", url: proxyBase + encodeURIComponent("https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard") },
        { label: "CFB", url: proxyBase + encodeURIComponent("https://site.api.espn.com/apis/site/v2/sports/football/college-football/scoreboard") },
        { label: "SOC", url: proxyBase + encodeURIComponent("https://site.api.espn.com/apis/site/v2/sports/soccer/scoreboard") }
    ];

    // Aggregated from 5 popular, reliable sports news sources
    const newsFeeds = [
        proxyBase + encodeURIComponent("https://www.espn.com/espn/rss/news"), // ESPN General
        proxyBase + encodeURIComponent("https://www.cbssports.com/rss/headlines/"), // CBS Sports General
        proxyBase + encodeURIComponent("https://www.foxsports.com/rss/all"), // Fox Sports General
        proxyBase + encodeURIComponent("https://sports.yahoo.com/rss/"), // Yahoo Sports
        proxyBase + encodeURIComponent("https://profootballtalk.nbcsports.com/feed/") // PFT (NFL focused, but high-value rumors)
    ];

    // --- Stream Engagement (Text Only) ---
    const engagementLines = [
        "WELCOME TO NSN â€¢ DROP YOUR FAVORITE TEAM IN CHAT FOR A SHOUTOUT!",
        "LIKE THE STREAM, FOLLOW THE CHANNEL, SHARE WITH A FRIEND!",
        "ðŸš¨ SONG REQUESTS: TYPE '!play Artist - Song Title' IN THE CHAT ðŸŽ¶",
        "NO COMMERCIALS â€¢ ONLY RAW SPORTS TALK, 24/7",
        "FIRST TIME HERE? SAY HI IN CHAT! WE'RE BUILDING THE BEST COMMUNITY!",
        "JOIN THE CLUB FOR EXCLUSIVE BADGES AND PERKS (1 COIN!)"
    ];

    const allTeamPrompts = [
        "NBA: Who is the true MVP favorite 1/4 into the season?",
        "NFL: Which surprise team is actually a legitimate contender?",
        "NHL: What team needs to make a panic trade before the deadline?",
        "CFB: Who are the 4 teams in your playoff bracket right now?",
        "LAKERS/CELTICS/SIXERS FANS: Who is the biggest threat in the East/West?",
        "COWBOYS FANS: Are you feeling hopeful or is it another year of disappointment?",
        "NFL RUMOR MILL: Which star player gets moved by the trade deadline?"
    ];

    let shuffledTeamPrompts = shuffle(allTeamPrompts);
    let currentPromptIndex = 0;


    // ==============================
    // HELPERS
    // ==============================
    function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]]; // Swap
        }
        return a;
    }

    /**
     * Adds an item to the scroll track HTML structure.
     * @param {string} text - The main content text.
     * @param {string} label - The category label (used for color/styling).
     */
    function addItem(text, label) {
        const span = document.createElement("span");
        span.className = "item";
        // Use class on label for dynamic color coding
        span.innerHTML = `<span class="label ${label.toUpperCase()}">${label}</span> ${text}`;
        track.appendChild(span);
    }
    
    /** Adds high-engagement, static lines to the track. */
    function addEngagement() {
        // Add all general NSN lines
        engagementLines.forEach(line => addItem(line, "CHAT"));
        
        // --- ONE ROTATING TEAM PROMPT ---
        if (shuffledTeamPrompts.length > 0) {
            addItem(shuffledTeamPrompts[currentPromptIndex], "TEAM");
            currentPromptIndex = (currentPromptIndex + 1) % shuffledTeamPrompts.length;
        }
    }


    // ==============================
    // LIVE DATA FETCHING
    // ==============================
    
    /** Fetches and formats live and final scores. */
    async function addScores() {
        const liveScores = [];
        const finalScores = [];

        for (const src of scoreboardSources) {
            try {
                let data;
                for (let attempt = 0; attempt < 3; attempt++) {
                    const res = await fetch(src.url);
                    if (res.ok) {
                        data = await res.json();
                        break;
                    }
                    // Exponential backoff
                    if (attempt < 2) await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                }
                
                if (!data || !data.events) continue;

                for (const ev of data.events) {
                    if (!ev.competitions || ev.competitions.length === 0) continue;
                    const comp = ev.competitions[0];
                    if (!comp.competitors || comp.competitors.length < 2) continue;

                    const statusObj = ev.status && ev.status.type ? ev.status.type : null;
                    const isFinal = statusObj && (statusObj.completed || statusObj.description.toLowerCase().indexOf("final") !== -1);
                    const isLive = statusObj && statusObj.state === 'in';
                    
                    let extra = "";
                    if (statusObj && statusObj.shortDetail) {
                        extra = statusObj.shortDetail;
                    }

                    const [c1, c2] = comp.competitors;

                    function getName(c) {
                        return c.team.abbreviation || c.team.shortDisplayName || "TEAM";
                    }

                    const t1 = getName(c1);
                    const t2 = getName(c2);
                    const s1 = c1.score ? c1.score : "0";
                    const s2 = c2.score ? c2.score : "0";

                    const label = isLive ? "LIVE" : "SCORE";
                    const statusText = extra ? `<span class="status-text">${extra}</span>` : '';
                    const itemContent = `${t1} ${s1} <span class="score-sep">-</span> ${s2} ${t2} ${statusText}`;

                    if (isLive) {
                        liveScores.push({ label: label, content: itemContent });
                    } else if (isFinal) {
                        finalScores.push({ label: label, content: itemContent });
                    }
                }
            } catch (e) {
                console.error(`Score fetch error for ${src.label}:`, e);
            }
        }

        // Prioritize Live Scores, then Final Scores
        liveScores.slice(0, 15).forEach(item => addItem(item.content, item.label));
        finalScores.slice(0, 10).forEach(item => addItem(item.content, item.label));
    }


    /** Fetches and formats news and rumors from 5 popular sources. */
    async function addNewsAndRumors() {
        const parser = new DOMParser();
        const rumorKeywords = [
            "rumor", "trade", "linked to", "talks", "interest", "shopping", "signing", "extension"
        ];
        let newsCount = 0;

        for (const feed of newsFeeds) {
            if (newsCount >= 30) break; // Cap total news items
            try {
                let text;
                for (let attempt = 0; attempt < 3; attempt++) {
                    const res = await fetch(feed);
                    if (res.ok) {
                        text = await res.text();
                        break;
                    }
                    // Exponential backoff
                    if (attempt < 2) await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                }

                if (!text) continue;

                const xml = parser.parseFromString(text, "text/xml");
                // Check for both RSS <item> and Atom <entry>
                const items = Array.from(xml.querySelectorAll("item, entry")).slice(0, 6); 

                items.forEach(it => {
                    if (newsCount >= 30) return;
                    
                    // Standard RSS title, fallback to Atom title
                    const titleNode = it.querySelector("title");
                    if (!titleNode) return;
                    const title = titleNode.textContent ? titleNode.textContent.trim() : "";
                    // Filter out boilerplate titles
                    if (!title || title.toLowerCase().startsWith('daily') || title.toLowerCase().startsWith('weekly') || title.toLowerCase().startsWith('rss feed')) return;

                    const lower = title.toLowerCase();
                    let isRumor = rumorKeywords.some(keyword => lower.includes(keyword));

                    addItem(title, isRumor ? "RUMOR" : "NEWS");
                    newsCount++;
                });
            } catch (e) {
                console.error("News error:", feed, e);
            }
        }
    }


    // ==============================
    // ANIMATION CONTROL & REFRESH LOGIC
    // ==============================
    
    /**
     * Resets and starts the CSS keyframe animation based on content width and speed.
     * Sets a timeout to refresh the content exactly when one cycle completes.
     */
    function restartAnimation(contentWidth) {
        // Clear any previous scheduled refresh
        if (refreshTimeout) {
            clearTimeout(refreshTimeout);
        }
        
        if (contentWidth === 0) {
            // If no content, refresh quickly and stop the animation
            track.style.animation = 'none';
            refreshTimeout = setTimeout(() => buildContent(false), 5000); 
            console.warn("No content in the ticker, retrying fetch in 5s.");
            return;
        }

        // Calculate the required duration based on pixels per second (Distance / Speed = Time)
        // The effective scroll distance is 50% of the track (the width of the original content).
        const durationSeconds = contentWidth / PIXELS_PER_SEC;
        const durationMS = durationSeconds * 1000;

        // 1. Clear existing animation style to restart
        track.style.animation = 'none'; 
        track.offsetHeight; // Force reflow
        
        // 2. Apply new animation properties
        // We use linear timing and infinite repetition.
        track.style.animation = `tickerScroll ${durationSeconds}s linear infinite`;

        // 3. Schedule the next content refresh to occur after one full loop (durationSeconds)
        // We ensure a minimum refresh time regardless of how fast the scroll is.
        const actualRefreshMS = Math.max(durationMS, REFRESH_MS_MIN);
        
        refreshTimeout = setTimeout(async () => {
            console.log(`Scroll cycle complete. Triggering live data refresh (${actualRefreshMS}ms).`);
            await buildContent(false);
        }, actualRefreshMS);
    }

    /**
     * Gathers all data (Scores, News, Engagement), builds the track, duplicates for seamless scrolling, and restarts the animation.
     * @param {boolean} isInitialLoad If true, only load engagement text to start the scroll instantly.
     */
    async function buildContent(isInitialLoad = false) {
        // Clear all previous content (This action removes the initial #loading-message element
        // if it was present inside the track).
        track.innerHTML = "";

        if (isInitialLoad) {
            // FIX: Removed the error-causing line document.getElementById('loading-message').remove(); 
            // as track.innerHTML = "" already clears it.
            addEngagement();
        } else {
            try {
                // 1. Add Live Scores
                await addScores();
                
                // 2. Add News and Rumors
                await addNewsAndRumors();
                
                // 3. Add Engagement/Static Content
                addEngagement();

                if (track.innerHTML.length === 0) {
                    addItem("Live Data fetch failed or is unavailable. Check console for API errors.", "SYSTEM");
                }
            } catch (e) {
                console.error("Critical build error:", e);
                addItem("CRITICAL ERROR: Data fetch failed. Check console.", "SYSTEM");
                addEngagement(); // Ensure engagement lines are present as fallback
            }
        }

        // 4. Duplicate the content for seamless CSS keyframe scrolling (MANDATORY)
        const originalContent = track.innerHTML;
        track.innerHTML += originalContent;

        // 5. Restart the animation with the new content width
        // The original content width is half of the total scrollWidth
        const originalContentWidth = track.scrollWidth / 2;
        restartAnimation(originalContentWidth);

        if (!isInitialLoad) {
             console.log("Ticker refreshed with live data. Next update scheduled at end of scroll cycle.");
        }
    }


    // --- Initialization ---
    
    document.addEventListener("DOMContentLoaded", async () => {
        // 1. Initial load: Start the scroll immediately with static engagement content.
        await buildContent(true);
        
        // 2. Run the first full live data refresh immediately after
        await buildContent(false);
    });

</script>

</body>
</html>
